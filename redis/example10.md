# Scan

  如何筛选Key进行管理？

### 粗暴的方法 => 正则表达式

```s
  # 查询所有的
  keys *

  # 查询xiao开头的
  keys xiao*
```

  这种查询为什么说它粗暴呢？无法分页是硬伤，当Key有成千上万个，那你想死的心都有了。

### Redis2.8中提供了scan指令

  scan指令主要有三个参数

```s
  # 现在我查询游标从0开始的10条数据
  scan 0 count 10

  # 注意上面的count并不一定精确

  # 下面我们结合正则 搜索游标从0开始的100条数据中的key开头的
  scan 0 match key* count 100
```

  如果需要查找一组数据，那么你就需要从游标0一直遍历到0， 通过不断获取上一次返回的游标获取数据。scan不会使服务卡顿。


### 字典的结构

  在Redis中所有的key都是存储在一个很大的字典中，而这个字典是一个一位数组+二维链表的结构。

  一维数组的大小为2^n，每次扩容则是n++。

  一维数组的位置索引可以称为槽（slot），如果不考虑扩容和缩容，直接按照数组下标挨个遍历即可。count则是需要遍历的槽位，之所以返回的结果可能多也可能少，是因为并不是所有的槽位上都有链表，有些槽位是空置的。

### scan遍历顺序

  scan的遍历的顺序十分特别，它是高位进位加法（与普通加法是相反的），主要是考虑字典扩容和缩容时避免槽位的遍历重复和遗漏。

### 字典的扩容

  相比较Java中HashMap的一次性更改旧元素（如果元素特别多，容易造成卡顿）。

  Redis中采用了渐进式rehash。它会同时保留新旧两个数组，通过定时任务将旧元素不断的迁移到新的数组中。所以scan在扫描rehash中的字典，需要同时同时扫描新旧数组。

### 警惕大key的出现

  - key太大，导致数据迁移卡顿
  - 越大的key当需要扩容时，则需要更大的内存。
  - 大key被释放时，内存一次性回收，也会导致卡顿。

  这里我们可以采用redis-cli中提供的指令寻找大Key

```s
  redis-cli -h 127.0.0.1 -p 6379 --bigkeys

  # 也可以加上休眠时间
  redis-cli -h 127.0.0.1 -p 7001 –-bigkeys -i 0.1

  # 删除所有的Key
  flushdb
```