# Codis

  Redis的另一种集群方案是国内开源的Codis(豌豆荚团队)。

### 前提

  在海量数据存储和高并发的场景下，单个Redis实例往往显得捉襟见肘，体现在：

  - 单个Redis的内存不宜过大，内存过大会导致RDB文件过大，从而导致主从同步时快照同步时间过长，在数据重启时会花费很长的加载时间，特别是在云环境下，对于内存大小的限制更是苛刻的。
  - 体现在CPU的利用率上，单个实例只能利用单个核心，从而数据存储和管理的压力会非常的大。

  而我们的集群方案就是将众多小内存的Redis实例分布在不同机器上，完成海量数据的存储和高并发读写操作。

### 简介

  Codis使用Go语言开发的，它是一个代理中间件。当客户端向Coids发送指令时，Codis负责将指令发送给后面的Redis实例执行，并将结果返回给客户端。

  Codis挂载的所有Redis实例构成一个集群，当集群空间不足时，可以动态添加Redis实例实现扩容的效果。

### Codis分片原理

  Codis是如何将特定的key转发到特定的Redis实例上？

  Coids将所有的key默认划分为1024个槽位(slot)，它首先对客户端传过来的key进行crc32运算计算哈希值，再将hash后的整数值对于1024这个整数进行取模获取余数，从而找到对应的槽位。

  如果你的集群节点较多，那么可以设置2048、4096.。。。

### 不同Codis之间的同步

  这里采用ZooKeeper管理

### 扩容

  比如一开始Codis中只有一个Redis，那么1024个槽位全部指向这个Redis。然后Redis的内存不够的时候，那么需要再添加一个Redis实例，那么就需要将一半槽位上的key迁移到新的Redis实例上。

  这里遇到的问题就是：如果找到槽位对应的所有key?

  Codis对Redis进行了改造，添加了SLOTSSCAN的命令，通过该命令扫描待迁移槽位下所有的key，然后挨个迁移每个key到新的节点上。

  Codis在迁移的过程中，仍然可以处理新的请求，如果遇到同时存在新旧槽点的key，那么就先迁移单个key，再处理请求。