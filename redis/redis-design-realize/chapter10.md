# AOF

### 一、什么是AOF？

  前面提到Redis默认采用RDB持久化的方式保存数据库的状态，而AOF不采用保存键值对的方式，而是记录Redis命令请求协议格式，Redis请求命令采用文本协议。

### 二、AOF持久化的实现


##### 追加

  当Redis执行一条写命令时，Redis会将命令以请求协议格式写入redisServer中的aof_buf，这就是追加操作。

##### 写入

  前面提到了serverCron每100毫秒执行一次，与RDB间隙保存类似的，不过AOF通过appendfsync属性设置不同的策略：

  - always: 将aof_buf中的内容写入并且同步
  - everysec: 将aof_buf中的内容写入AOF文件，如果上一次同步AOF文件超过1秒钟，那么会再次同步，这个操作是由一个专门的线程处理的。
  - no: 将aof_buf中的内容写入到AOF文件，但是同步的操作完全由系统自己把握

  分析上面这几个选项，always的安全性是最高的，最多也就丢失一个时间循环的数据；everysec相对性能好一点，不过可能会丢失前一秒的数据；no的效率是最高的，但是丢失的是上一次同步操作之后的所有数据。

  Redis对于AOF文件的载入步骤：

  - 创建一个不带网络连接的伪客户端（Redis命令只能在客户端上下文中执行），直接读取AOF文件
  - 读出一条写命令
  - 伪客户端执行该命令
  - 直到所有命令执行完毕

### 重写

  当系统持续的运行，会产生大量的命令，从而导致AOF非常的大，这里就需要对AOF进行优化，也就是这里的重写。

  虽然它的名字叫做重写，但是实际上并不是对于现有AOF文件的重写，而是直接操作当前的Redis数据库。

  重写的原理就是，从当前数据库中读取键现有的值，通过一条命令去记录键值对从而代替之前执行多条命令记录键值对，当然如果一个键含有成千上万个键值对，不可能采用一条写命令，这里会根据REDIS_AOF_REWRITE_ITEMS_PER_CMD设置的值划分，默认是64个，可能不同版本不太一样。

  重写操作放在子进程中执行，这样可以让服务器在父进程中继续处理请求。子进程携带父进程的数据副本，从而保证数据的一致性。

  当然当我们开启重写，主进程仍然在接收数据，如果不加处理，那么处理完重写之后的数据必然和主进程中的不一致，所以Redis中又添加了一个aof_rewrite_buf，当子进程执行完重写后，再将AOF重写缓冲区中的内容追加，那么就和主进程中的数据达到了一致。

  所以在执行一条写命令时，不仅要写入aof_buf，还要写入aof_rewrite_buf。

  实际上这就是命令BGREWRITEAOF的实现原理。