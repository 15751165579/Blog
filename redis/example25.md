# LRU

  在我们不断的向Redis存储内容时，如果Redis内存使用超出了物理内存的限制，那么内存数据会开始和磁盘频繁的交换，这会让Redis的性能急剧的下降，所以Redis中提供了最大内存限制来避免这种情况。

### 限制的策略（maxmemory-policy）

  - noeviction: 这种方式不会继续服务写操作，读操作仍然可以进行，这是默认的淘汰策略。
  - valatile-lru: 尝试淘汰设置过期时间的key，最少使用的key优先淘汰。
  - valatile-ttl: 根据key的ttl淘汰，ttl值越小越被淘汰。
  - valatile-random: 在过期key集合中随机淘汰。
  - allkeys-lru: 范围扩至所有的key，和valatitle-lru一样。
  - allkeys-random: 类似valatitle-random

### LRU算法

  实现LRU算法不仅仅需要一个字典，还需要一个链表。链表中的元素按照一定的顺序排列，当空间满了之后，会优先删除尾部的元素，当字典中某个元素被访问时，它会被提到链表的头部。所以链表中元素排列的顺序实际上就是元素被访问的时间顺序。

  Redis中为了减少链表带来的额外空间，通过给每个key增加一个额外的字段（24bit）,也就是最后访问的时间戳。

  前面提到对于过期key的处理，Redis采用集中处理和惰性处理。这里lru算法也是采用惰性处理的方式，当Redis执行写操作的时候，发现内存超出，那么就会执行一次lru淘汰（随机抽出5个key，淘汰最旧的那个）,如果内存仍然超过，继续执行前面的步骤。