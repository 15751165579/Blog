# 惰性删除的巨大牺牲

  异步线程在Redis内部有一个特别的名称，它就是BIO（Background IO），当然内存回收本身并不是什么IO操作，只不过CPU计算消耗可能会大一点。

### 最初的惰性删除策略

  一开始作者并不是采用异步线程处理惰性删除，而是放在主线程中。

  放在主线程中，你需要为每种数据结构适配一套渐进式的释放策略，并且需要搞一个自适应算法来仔细控制回收的频率。但是实现之后的效率并不能达到预期，之后作者才考虑使用异步线程处理惰性删除。

  不过使用异步线程也是有代价的，主线程和异步线程之间在内存回收器上的竞争，这点竞争是可以忽略不计的，因为Redis主线程在内存分配和回收上花的时间相对于整体运算时间是非常少的。

### 异步线程方案

  当然异步线程方案并没有那么简单。

  难点： 内部对象的共享机制。

  当底层的字符串被多个key共享时，你删除其中一个key，那么就以为着要彻底删除，而底层对象是共享的，你是做不到彻底删除的。

  不过最后作者花费了巨大的精力将对象共享机制删除，也就是[share-nothing]